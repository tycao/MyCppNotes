# MyCppNotes
record my daily notes for C++ here

## C++派生类的构造函数和析构函数的细节
- `执行一个派生类的构造函数之前，总是先执行基类的构造函数`。
- `派生类对象消亡时，先执行派生类的析构函数，再执行基类的析构函数`。

> 派生类的成员包括派生类自己定义的成员、直接基类中定义的成员，以及所有间接基类的全部成员。（父亲是儿子的直接基类，爷爷是儿子的间接基类）

> 派生类对象中 包含基类对象。因此派生类对象在创建时：除了要`调用自身的构造函数进行初始化之外`，还要调用`基类的构造函数初始化其包含的基类`。
所以，生成派生类对象的语句，包含了基类对象是如何初始化的。

**当派生类的对象生成时，会从最顶层的基类开始逐层往下执行所有基类的构造函数，最后再执行自身的构造函数；当派生类对象消亡时，会先执行自身的析构函数，然后从底向上依次执行各个基类的析构函数。**

- [x] [C++派生类的构造函数和析构函数的细节](https://zhuanlan.zhihu.com/p/143131845?utm_source=wechat_session&utm_medium=social&utm_oi=1135453983547121664&s_r=0)<br />

## C++虚函数表在运行时候是如何存在的
主流 C++ 实现（gcc/clang/VC++）对于最简单的单继承且基类有虚函数的情况（非虚拟继承）的做法都差不多：
- `vtable` **是每个`class`类型一个** ，不是每个对象一个。`vtable` 的大小（长度）跟这个`class的虚函数总数`（继承和自己新增）正相关。
- `vptr` **是每个`对象`一个** ，`vptr` **大小是固定的，跟虚函数多少无关**。
- 对象的 `vptr` **在构造和析构的时候可能会变，指向不同的`vtable`**。对象构造完就不会变了。
- “只使用前一段”有可能发生，如果派生类添加了新的虚函数的话（比如 virtual void B::print()）。




- [x] [C++虚函数表在运行时候是如何存在的](https://www.zhihu.com/question/53178142?utm_medium=social&utm_oi=1135453983547121664&utm_source=wechat_session&s_r=0)<br />